# Scheme - интерпретатор на C++

Учебный интерпретатор подмножества **Scheme** (LISP‑подобный язык) на C++:  
**tokenize → parse (AST) → eval**.

Проект читает выражения языка, вычисляет их и возвращает результат.

```scheme
1              => 1
(+ 1 2)        => 3
(+ 2 (/ -3 4)) => 1
```

`=>` в примерах отделяет выражение от результата вычисления.

---

## Возможности

### Типы данных
- **Примитивы:** целые числа, `boolean`, **символы** (идентификаторы)
- **Составные:** пары и списки

### Переменные и функции
- переменные с **лексической областью видимости**
- функции и `lambda` с захватом контекста (замыкания)

### Поддерживаемые формы
- `quote`
- `if`
- `define`
- `lambda`
- `set!`
- и др.

### Builtins
- арифметика: `+ - * /`
- списки: `cons car cdr list`
- предикаты: `null? pair? number? symbol? boolean?`
- сравнения: `< > <= >= =`

---

## Как это работает

Выполнение выражения проходит в 3 этапа:

1) **Токенизация**  
Преобразует текст программы в последовательность (скобки, числа, символы и т.п.).

2) **Парсинг**  
Преобразует токены в дерево (AST). В Lisp‑подобных языках AST естественно представляется **списками**.

3) **Вычисление (eval)**  
Рекурсивный обход AST и вычисление по правилам языка и окружения (scope).

---

## Пример разбора

Выражение:

```scheme
(+ 2 (/ -3 +4))
```

после токенизации выглядит как последовательность:

- `(`
- `+`
- `2`
- `(`
- `/`
- `-3`
- `4`
- `)`
- `)`

Парсер превращает это в список/дерево (S‑expression), после чего evaluator вычисляет результат:

```scheme
(+ 2 (/ -3 +4)) => 1
```

---

## Сборка

```bash
cmake -S . -B build -DCMAKE_BUILD_TYPE=Release
cmake --build build -j
```

---

## Организация кода

Код разбит на логические части:
- **tokenizer** - поток символов → токены
- **parser** - токены → AST
- **evaluator** - вычисление выражений в окружении (scope)
- **objects** - представление значений (числа/символы/пары/списки)

---
